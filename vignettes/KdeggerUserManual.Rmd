---
title: "KdeggeR user manual"
author: "Barbora Salovska"
date: "Last edited `r format(Sys.Date(), '%A %d %B %Y')`"
output:
  rmdformats::readthedown:
    code_folding: show
    self_contained: true
    thumbnails: false
    lightbox: false
    number_sections: yes
    toc_depth: 3
    toc_float: yes
pkgdown:
  as_is: true    
vignette: >
  %\VignetteIndexEntry{KdeggerUserManual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(dplyr)
library(magrittr)
```

# Load the package

## Install dependencies

```{r install dependencies, eval = FALSE}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(devtools, dplyr, outliers, parallel, purrr, stats, stringr, tibble)

# Optional
# install.packages("MASS")
```

## Install KdeggeR

```{r install KdeggeR, eval = FALSE}
library("devtools")
install_github("yslproteomics/KdeggeR")
```

## Load KdeggeR

```{r load KdeggeR}
library(KdeggeR)
```

# Required files 

1. Precursor-level data exported in .tsv format
2. Design table saved in .tsv format
3. OPTIONAL: Table with experimentally determined kcd values in .tsv format

## Data
  - The data can be either provided as a path to the file or can be a data.frame already loaded in the R environment.
  - The data must contain light and heavy intensity columns, a protein id column, and a precursor id column. Other columns are optional. 
  - If the data has been pre-loaded in the R environment, the data must have row names corresponding to precursor ids.
  - See examples in the code chunks below. 

### Spectronaut data, labeled workflow
  - Required columns: `PG.ProteinGroups`, `EG.PrecursorId`
  - Light intensities: columns ending with `EG.Channel1Quantity`
  - Heavy intensities: columns ending with `EG.Channel2Quantity`
  - Example data are provided, see `KdeggeR::example_spectronaut` to check the expected data structure
  
```{r example data lbl}
KdeggeR::example_spectronaut %>%
  dplyr::glimpse()
```
 
### Spectronaut data, ISW workflow 
  - In SN19, the same columns can be exported and use
  - In older SN versions: 
    - The light channel quantities are named as `EG.ReferenceQuantity`
    - The heavy channel quantities are named `EG.TargetQuantity`
    - In this case, rename the columns, so they match to the expected format, e.g., using the code in the chunk below. 

```{r example data isw, eval = FALSE}
KdeggeR::example_spectronaut_isw %>%
  dplyr::rename_with(~gsub("EG.TargetQuantity", "EG.Channel2Quantity", .), .cols = dplyr::ends_with("EG.TargetQuantity")) %>%
  dplyr::rename_with(~gsub("EG.ReferenceQuantity", "EG.Channel1Quantity", .), .cols = dplyr::ends_with("EG.ReferenceQuantity"))
```

### DIA-NN and Fragpipe data, plexDIA
  - Recommended output: 
  - Required columns: `Protein.Group`, `Precursor.Id`
  - Light intensities: columns ending with `.L`
  - Heavy intensities: columns ending with `.H`
  - Example data are provided, see `KdeggeR::example_diann` to check the expected data structure

```{r example data dia_nn, eval = FALSE}
KdeggeR::example_diann %>%
  dplyr::glimpse()
```

## Design table
  - The design can be either provided as a path to the file or can be a data.frame already loaded in the R environment.
  - If the data has been pre-loaded in the R environment, the table must have row names corresponding to raw file names.
  - Mandatory columns: 
    1. sample
    2. time (numeric, in hours)
  
  - Optionall columns: 
    1. replicates (numeric) - needed replicate design analysis. Note replicates of the same sample should have the same value in the column sample of the design table if replicate design is used. See examples.  
    2. color - customize data plotting in post-analysis. 
    3. condition  

### Design table without replicate design
  - If there are no replicates to be averaged before data processing.
  - Unique sample names must be specified in the `sample` column
  - The labeling time point must be specified in the `time` column

```{r example design lbl}
# Examine the data structure
KdeggeR::example_spectronaut_design %>%
  dplyr::glimpse()

# Examine the row names
row.names(KdeggeR::example_spectronaut_design)
```

### Design table with replicate design
  - If there are replicates that needs to be combined before analysis, the `sample` column needs to be specified accordingly to group the replicates 
  - The `replicate` column must contain information about the replicates (numeric).
  - The labeling time point must be specified in the `time` column

Note, if replicate design is used, the data will be combined in the beginning of the processing, and all subsequent steps are performed with the averaged data (such as RIA calculation, data filtering, kloss modeling, etc..). 

```{r example design lbl replicates}
# Examine the data structure
KdeggeR::example_spectronaut_design_replicates %>%
  dplyr::glimpse()

# Examine the row names
row.names(KdeggeR::example_spectronaut_design_replicates)
```

### Generate design table based on the results file

  - The `generate_design_template()` function can be used to generate a customizable design table template based on the data file. 
  - In this case, a path to the data file must be provided - example tsv files are provided in the data directory. 
  - A tsv file is exported, which can be customized by the user, saved as a .tsv file and used as an input for the `generatepSILACObject()` function.
  
```{r generate design table, eval = FALSE}
# use path to the file
input_data <- paste(.libPaths()[1], "KdeggeR/data/example_data_pSILAC_SN19.tsv", sep = "/")

KdeggeR::generateDesignTemplate(dataset = input_data, inputDataType = "spectronaut")
```

## kcd table

  - A simple kcd table with two columns can be provided to be used for kdeg calculation. 
  - The table must contain a `sample` column identical to the `sample` column in the design table, and a `kcd` column containing experimentally-derived cell doubling rates. 
  - See an example table below. 
  
```{r load kcd table}
KdeggeR::example_kcd %>%
  glimpse()
```

# Generate pSILAC object

## Function description

The pSILAC object is generated using the design table and the data using the `generatepSILACobject()` function. The function prepares the R object, filters and/or averages the intensity data, and calculates the RIA(Light), ln(H/L + 1), and NLI values, which are then used for downstream processing.  

The input data can be either loaded on R environment or provided as a path to the file. The `inputDataType` parameter must be correctly specified as `spectronaut`, `diann`, `fragpipe`, `maxquant`, or `openswath`. 

For no replicate averaging, please set the `aggregate.replicates` parameter to `NA`. In this workflow, all unique conditions defined using the sample column in the design table will be processed independently. For replicate averaging, set the `aggregate.replicates` parameter to either `mean` or `median` and provide a design table with the replicate indicated (as described above). When the replicate design is activated, the light and heavy intensities will be averaged using the selected method before any downstream filtering and analysis. 

Specify the number of cores that will be used for the analysis using the paramater `ncores`. By default set to 1, if NULL, the number of cores will be determined as `detectCores() - 1`. 

The `filterPeptides` parameter will remove peptides with no lysine or arginine residues and can be used by default in a classic pSILAC experiment using stable isotopes of both lysine and arginine. 

Specify the intensity cutoff to remove low intensity signal. For the example dataset (i.e., analyzed with Spectronaut 19 and acquired using an Orbitrap Fusion Lumos platform) we recommed to use a cutoff of 8. This filtering can be performed in the quantification step in Spectronaut (from 19.3 onwards). Note, removing these extremely low values leads to a dramatic improvement of H/L ratio quantification in early time points of a pSILAC experiment. 

The `requant` and `inpute.method` parameters are only relevant when working with OpenSwath results in long format. 

See `?generatepSILACObject` for a full documentation. 

## Examples

### Spectronaut 19 example without replicate design

  - Use example data provided in the KdeggeR package. 

```{r generate pSILAC object Spectronaut in R without replicates, eval = TRUE}
input_data <- KdeggeR::example_spectronaut
input_design <- KdeggeR::example_spectronaut_design

pSILAC_object <- KdeggeR::generatepSILACObject(dataset = input_data, 
                                   design = input_design, 
                                   inputDataType = "spectronaut",
                                   aggregate.replicates = NA, # if NA, replicates are not aggregated
                                   filterPeptides = T, 
                                   ncores = NULL,
                                   noiseCutoff = 8)
```

### Spectronaut 19 example with replicate aggregation

  - Use example data provided in the KdeggeR package. 
  - The replicates will be averaged during the pSILAC object generation. 
  - This design is advisable when processing experiments with, e.g., replicate injections or dish replicates. 

```{r generate pSILAC object Spectronaut in R with replicates, eval = TRUE}
input_data <- KdeggeR::example_spectronaut
input_design <- KdeggeR::example_spectronaut_design_replicates

pSILAC_object <- KdeggeR::generatepSILACObject(dataset = input_data, 
                                   design = input_design, 
                                   inputDataType = "spectronaut",
                                   aggregate.replicates = "mean", # can be "mean" or "median"
                                   filterPeptides = T, 
                                   ncores = NULL,
                                   noiseCutoff = 8)
```

### Spectronaut 19 example, use filepath

  - The files are provided in the data directory. 
  - The function will load the files using the provided paths and process the data. 

```{r generate pSILAC object using file path, eval = FALSE}
# design without replicates
input_data <- paste(.libPaths()[1], "KdeggeR/data/example_data_pSILAC_SN19.tsv", sep = "/")
input_design <- paste(.libPaths()[1], "KdeggeR/data/example_design_table_pSILAC_SN19_no_replicates.txt", sep = "/")

pSILAC_object <- KdeggeR::generatepSILACObject(dataset = input_data, 
                                   design = input_design, 
                                   inputDataType = "spectronaut", # inputDataType needs to be correctly specified
                                   aggregate.replicates = NA, # if NA, replicates are not aggregated
                                   filterPeptides = T, 
                                   ncores = NULL,
                                   noiseCutoff = 8)

# design with replicates
input_design <- paste(.libPaths()[1], "KdeggeR/data/example_design_table_pSILAC_SN19_replicates.txt", sep = "/")

pSILAC_object <- KdeggeR::generatepSILACObject(dataset = input_data, 
                                   design = input_design, 
                                   inputDataType = "spectronaut", # inputDataType needs to be correctly specified
                                   aggregate.replicates = "mean", # can be "mean" or "median" 
                                   filterPeptides = T, 
                                   ncores = NULL,
                                   noiseCutoff = 8)
```

# Filter data

```{r filter input data, eval = FALSE}
pSILAC_object <- filterValidValues(pSILAC_object, values_cutoff = 2, skip_time_point = 1)
pSILAC_object <- filterMonotone(pSILAC_object, skip_time_point = 1)
pSILAC_object <- filterMonotoneTimePoint1(pSILAC_object)
pSILAC_object <- filterLinearRegression(pSILAC_object, skip_time_point = 1, R2_cutoff = 0.9, p_cutoff = 0.05)
```

# Fit models to estimate Kloss

## Calculate all rates

The `calcAllRates()` function is a wrapper function that runs precursor kloss calculation using the RIA, ln(H/L +1), and NLI data. 

Then it aggregates the precursor-level estimates into protein kloss estimates using the selected method.

```{r fit all rates, eval = FALSE}
pSILAC_object <- calcAllRates(pSILAC_object, method = "complement", 
                  ag.metric = "mean", 
                  ag.weights = "both")
```

## Calculate specific rates

The model fitting functions can be also run separately using the following functions. 

```{r fit selected rates, eval = FALSE}
# Precursor-level kloss
pSILAC_object <- calcRIAkloss(pSILAC_object, ncores = 1)
pSILAC_object <- calcNLIkloss(pSILAC_object, startIntensity = "max", ncores = 1)
pSILAC_object <- calcHoLkloss(pSILAC_object, tryRobust = FALSE, ncores = 1)

# Aggregate to protein-level kloss
pSILAC_object <- calcProteinsKloss(pSILAC_object, method = "complement", 
                       ag.metric = "mean", 
                       ag.weights = "both", 
                       ncores = 1, 
                       returnKlossTableOnly = F, 
                       returnSD = F )

# Aggregate to protein-level kloss, export protein-level kloss table in a new object
protein_kloss_table <- calcProteinsKloss(pSILAC_object, method = "complement", 
                       ag.metric = "mean", 
                       ag.weights = "both", 
                       ncores = 1, 
                       returnKlossTableOnly = T, 
                       returnSD = F )
```

# Calculate kdeg 

## Import experimentally-determined kcd values

```{r example kcd}
KdeggeR::example_kcd %>%
  glimpse()
```


## Calculate kdeg

## Calculate t(1/2)

# Visulize Results

## Precursor/peptide

### Plot precursor RIA model

### Plot precursor NLI model

### Plot precursor ln(H/L +1) model

## Protein

### Plot protein model

### Plot protein summary
