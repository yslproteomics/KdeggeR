---
title: "KdeggeR user manual"
author: "Barbora Salovska"
date: "Last edited `r format(Sys.Date(), '%A %d %B %Y')`"
output:
  rmdformats::readthedown:
    code_folding: show
    self_contained: true
    thumbnails: false
    lightbox: false
    number_sections: yes
    toc_depth: 3
    toc_float: yes
pkgdown:
  as_is: true    
vignette: >
  %\VignetteIndexEntry{KdeggerUserManual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(dplyr)
```

# Load the package

## Install dependencies

```{r install dependencies, eval = FALSE}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(devtools, dplyr, outliers, parallel, purrr, stats, stringr, tibble)

# Optional
# install.packages("MASS")
```

## Install KdeggeR

```{r install KdeggeR, eval = FALSE}
library("devtools")
install_github("yslproteomics/KdeggeR")
```

## Load KdeggeR

```{r load KdeggeR}
library(KdeggeR)
```

# Required files 

1. Precursor-level data exported in .tsv format
2. Design table saved in .tsv format
3. OPTIONAL: Table with experimentally determined kcd values in .tsv format

## Data
  - The data can be either provided as a path to the file or can be a data.frame already loaded in the R environment.
  - The data must contain light and heavy intensity columns, a protein id column, and a precursor id column. Other columns are optional. 
  - If the data has been pre-loaded in the R environment, the data must have row names corresponding to precursor ids.
  - See examples in the code chunks below. 

### Spectronaut data, labeled workflow (recommended)
  - Required columns: PG.ProteinGroups, EG.PrecursorId
  - Light intensities: columns ending with "EG.Channel1Quantity"
  - Heavy intensities: columns ending with "EG.Channel2Quantity"
  - Example data are provided, see `KdeggeR::example_spectronaut` to check the expected data structure
  
```{r example data lbl}
KdeggeR::example_spectronaut %>%
  dplyr::glimpse()
```
 
### Spectronaut data, ISW workflow 
  - In SN19, the same columns can be used
  - In older SN versions: 
    - The light channel quantities are contained in the "EG.ReferenceQuantity"
    - The heavy channel quantities in the "EG.TargetQuantity"
    - In this case, rename the columns, so they match to the expected format, e.g., using the code in the chunk below. 

```{r example data isw, eval = FALSE}
KdeggeR::example_spectronaut_isw %>%
  dplyr::rename_with(~gsub("EG.TargetQuantity", "EG.Channel2Quantity", .), .cols = dplyr::ends_with("EG.TargetQuantity")) %>%
  dplyr::rename_with(~gsub("EG.ReferenceQuantity", "EG.Channel1Quantity", .), .cols = dplyr::ends_with("EG.ReferenceQuantity"))
```

## Design table
  - The design can be either provided as a path to the file or can be a data.frame already loaded in the R environment.
  - If the data has been pre-loaded in the R environment, the table must have row names corresponding to raw file names.
  - The table must have a **sample** column and **time** column (numeric, in hours). 
  
  - Optionally, **replicates** (numeric) can be specified for a replicate design analysis.
  - Note, if there are replicates to be averaged, they should have the same value in the column **sample** of the design table. 
  - Optionally, the **color** column can be specified to customize data plotting in post-analysis. 
  - Optionally, the **condition** column can be specified. 

### Design table without replicate design
  - If there are **no replicates** or there are supposed to be analyzed separately, the **sample** column needs to be provided accordingly. 

```{r example design lbl}
# Examine the data structure
KdeggeR::example_spectronaut_design %>%
  dplyr::glimpse()

# Examine the row names
row.names(KdeggeR::example_spectronaut_design)
```

### Design table with replicate design
  - If there are replicates that needs to be combined before analysis, the **sample** column needs to be provided accordingly to group the samples. 
  - The **replicate** column must contain information about the replicates (numeric). 
  - Note, if replicate design is used, the data will be combined in the beginning of the processing, and all subsequent steps are performed with the averaged data (such as RIA calculation, data filtering, kloss modeling, etc..). 

```{r example design lbl replicates}
# Examine the data structure
KdeggeR::example_spectronaut_design_replicates %>%
  dplyr::glimpse()

# Examine the row names
row.names(KdeggeR::example_spectronaut_design_replicates)
```

### Generate design table based on the results file

  - The "generate_design_template()" function can be used to generate a customizable design table template based on the data file. 
  - In this case, a path to the data file must be provided. 
  - A tsv file is exported, which can be customized by the user, saved as a .tsv file and used as an input for the `generatepSILACObject()` function.
  
```{r generate design table, eval = FALSE}
# use libpath here
data_file <- paste(.libPaths()[1], "KdeggeR/data-raw/example_data_pSILAC_SN19_A2780Cis_Nor_full_truncated.tsv", sep = "/")

# See ?generateDesignTemplate
KdeggeR::generateDesignTemplate(dataset = data_file, inputDataType = "spectronaut")
```

## kcd table

  - A simple kcd table with two columns can be provided to be used for kdeg calculation. 
  - The table must contain a "sample" column identical to the "sample" column in the design table, and 
  - a "kcd" column containing experimentally-derived cell doubling rates

# Generate pSILAC object

## Generate pSILAC object without replicate design

```{r generate pSILAC object, eval = FALSE}
design_table_customized <- paste(.libPaths()[1], "KdeggeR/data/example_design_table_pSILAC_SN19_A2780Cis_Nor.txt", sep = "/")

# See ?generatepSILACObject
pSILAC_object <- KdeggeR::generatepSILACObject(dataset = data_file, 
                                   design = design_table_customized, 
                                   inputDataType = "spectronaut", # inputDataType needs to be correctly specified
                                   aggregate.replicates = NA, # if NA, replicates are not aggregated
                                   ncores = 1, # can be increased for faster processing, use parallel:: detectCores() to detect available cores
                                   noiseCutoff = 8) # intensity cutoff recommended for Spectronaut output data

```

## Generate pSILAC object with replicate design

The replicates will be averaged during the pSILAC object generation. This design is advisable when processing experiments with, e.g., replicate injections or dish replicates which are not meant to be analyzed separately.

It is recommended to use cross-run normalized data if replication aggregation is intended. 

```{r generate pSILAC object with replicates, eval = FALSE}
design_table_customized_replicates <- paste(.libPaths()[1], "KdeggeR/data/example_design_table_pSILAC_SN19_A2780Cis_Nor_replicate_design.txt", sep = "/")

pSILAC_object_agg <- KdeggeR::generatepSILACObject(dataset = data_file, 
                                       design = design_table_customized_replicates, 
                                       inputDataType = "spectronaut", 
                                       aggregate.replicates = "median")
```

# Filter data

```{r filter input data, eval = FALSE}
pSILAC_object <- filterValidValues(pSILAC_object, values_cutoff = 2, skip_time_point = 1)
pSILAC_object <- filterMonotone(pSILAC_object, skip_time_point = 1)
pSILAC_object <- filterMonotoneTimePoint1(pSILAC_object)
pSILAC_object <- filterLinearRegression(pSILAC_object, skip_time_point = 1, R2_cutoff = 0.9, p_cutoff = 0.05)
```

# Fit models to estimate Kloss

## Calculate all rates

The `calcAllRates()` function is a wrapper function that runs precursor kloss calculation using the RIA, ln(H/L +1), and NLI data. 

Then it aggregates the precursor-level estimates into protein kloss estimates using the selected method.

```{r fit all rates, eval = FALSE}
pSILAC_object <- calcAllRates(pSILAC_object, method = "complement", 
                  ag.metric = "mean", 
                  ag.weights = "both")
```

## Calculate specific rates

The model fitting functions can be also run separately using the following functions. 

```{r fit selected rates, eval = FALSE}
# Precursor-level kloss
pSILAC_object <- calcRIAkloss(pSILAC_object, ncores = 1)
pSILAC_object <- calcNLIkloss(pSILAC_object, startIntensity = "max", ncores = 1)
pSILAC_object <- calcHoLkloss(pSILAC_object, tryRobust = FALSE, ncores = 1)

# Aggregate to protein-level kloss
pSILAC_object <- calcProteinsKloss(pSILAC_object, method = "complement", 
                       ag.metric = "mean", 
                       ag.weights = "both", 
                       ncores = 1, 
                       returnKlossTableOnly = F, 
                       returnSD = F )

# Aggregate to protein-level kloss, export protein-level kloss table in a new object
protein_kloss_table <- calcProteinsKloss(pSILAC_object, method = "complement", 
                       ag.metric = "mean", 
                       ag.weights = "both", 
                       ncores = 1, 
                       returnKlossTableOnly = T, 
                       returnSD = F )
```

# Calculate kdeg 

## Import experimentally-determined kcd values

## Estimate kperc

## Calculate kdeg

## Calculate t(1/2)

# Visulize Results

## Precursor/peptide

### Plot precursor RIA model

### Plot precursor NLI model

### Plot precursor ln(H/L +1) model

## Protein

### Plot protein model

### Plot protein summary
