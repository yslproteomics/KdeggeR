#' @title A wrapper function to filter data based on monotone filtering in the first time point
#'
#' @description A wrapper to apply the filter_monotone_trend_tp1excluded function to all pSILAC labeling series in the dataset.
#'
#' @param o a pSILAC object
#' @param values_cutoff Specifies the minimum number of valid values to keep per pSILAC labeling series. Default is 2.
#' @param skip_time_point Specifies how many early time points should be excluded from valid value filtering. Default is 1.
#' @importFrom dplyr filter select
#' @return A filtered data frame.
#' @export
filterMonotoneTimePoint1 <- function(o){
  
  if (class(o) != "pSILAC") stop("Input data should be a pSILAC object.")
  
  # Define individual samples based on the design table
  samples <- o$design$sample
  
  #############################################################################
  # Use the RIA data frame from the pSILAC object
  ria_data <- o$RIA
  
  # Original column order
  original_order <- colnames(o$RIA)
  
  # Split data into individual pSILAC labeling series
  split_ria <- lapply(split.default(ria_data, samples), as.data.frame)
  
  # Filter data based on valid values
  message(paste(Sys.time(), "Filtering the first time point of RIA data based on monotone decrease.", sep = " "))
  
  split_ria <- lapply(split_ria, filter_monotone_trend_tp1only, mode = "RIA")
  
  split_ria <- lapply(split_ria, function(x) { x$id <- row.names(x); return(x) })
  
  filter_ria <- purrr::reduce(split_ria, dplyr::full_join, by = "id")
  
  row.names(filter_ria) <- filter_ria$id
  
  o$RIA <- filter_ria %>%
    dplyr::select(-id) %>%
    dplyr::select(all_of(original_order))
  
  message(paste(Sys.time(), "Completed", sep = " "))
  
  #############################################################################
  # Use the HOL data frame from the pSILAC object
  hol_data <- o$hol
  
  # Original column order
  original_order <- colnames(o$hol)
  
  # Split data into individual pSILAC labeling series
  split_hol <- lapply(split.default(hol_data, samples), as.data.frame)
  
  # Filter data based on valid values
  message(paste(Sys.time(), "Filtering the first time point of ln H/L data based on monotone increase.", sep = " "))
  
  split_hol <- lapply(split_hol, filter_monotone_trend_tp1only, mode = "HOL")
  
  split_hol <- lapply(split_hol, function(x) { x$id <- row.names(x); return(x) })
  
  filter_hol <- purrr::reduce(split_hol, dplyr::full_join, by = "id")
  
  row.names(filter_hol) <- filter_hol$id
  
  o$hol <- filter_hol %>%
    dplyr::select(-id) %>%
    dplyr::select(all_of(original_order))
  
  message(paste(Sys.time(), "Completed", sep = " "))
  
  #############################################################################
  # Use the NLI data frame from the pSILAC object
  NLI_data <- o$NLI
  
  # Original column order
  original_order <- colnames(o$NLI)
  
  # Split data into individual pSILAC labeling series
  split_NLI <- lapply(split.default(NLI_data, samples), as.data.frame)
  
  # Filter data based on valid values
  message(paste(Sys.time(), "Filtering the first time point of NLI data based on monotone decrease.", sep = " "))
  
  split_NLI <- lapply(split_NLI, filter_monotone_trend_tp1only,  mode = "NLI")
  
  split_NLI <- lapply(split_NLI, function(x) { x$id <- row.names(x); return(x) })
  
  filter_NLI <- purrr::reduce(split_NLI, dplyr::full_join, by = "id")
  
  row.names(filter_NLI) <- filter_NLI$id
  
  o$NLI <- filter_NLI %>%
    dplyr::select(-id) %>%
    dplyr::select(all_of(original_order))
  
  message(paste(Sys.time(), "Completed", sep = " "))
  
  return(o)
}


#' @title Filter the first time point based on monotone filtering
#'
#' @description The input is a data frame  frame split into a list based on grouping defined in the design object. 
#'
#' @param data A data frame containing values from one pSILAC labeling series.
#' @param mode Specifies whether the filtering is performed with the "RIA", "HOL", or "NLI" values. 
#' @importFrom dplyr filter select
#' @return A filtered data frame.
#' @export
filter_monotone_trend_tp1only <- function(data, mode = NULL){
  
  if(is.null(mode)){
    stop("Please specify the datatype (ria, hol) to use the correct assumption")
  }
  
  # report the first value from the vector generated by diff function per row
  # in those with non-missing values in tp1, this values corresponds to the difference from the next value
  data$compare_timepoints <- apply(data, 1, function(x){diff(na.omit(x))[1]})
  data$isna_tp1 <- is.na(data[,1])
  
  data_tp1_missing <- data %>%
    filter(isna_tp1 == TRUE)
  
  data_tp1_decide <- data %>%
    filter(isna_tp1 == FALSE)
  
  if(mode == "RIA"){
    
    data_tp1_decide[,1] <- ifelse(data_tp1_decide$compare_timepoints < 0, data_tp1_decide[,1], NA)
    
    data_filtered <- data_tp1_decide %>%
      bind_rows(data_tp1_missing) %>%
      select(-compare_timepoints, -isna_tp1)
    
  } else if(mode == "NLI"){
    
    data_tp1_decide[,1] <- ifelse(data_tp1_decide$compare_timepoints < 0, data_tp1_decide[,1], NA)
    
    data_filtered <- data_tp1_decide %>%
      bind_rows(data_tp1_missing) %>%
      select(-compare_timepoints, -isna_tp1)
    
  } else if(mode == "HOL"){
    
    data_tp1_decide[,1] <- ifelse(data_tp1_decide$compare_timepoints > 0, data_tp1_decide[,1], NA)
    
    data_filtered <- data_tp1_decide %>%
      bind_rows(data_tp1_missing) %>%
      select(-compare_timepoints, -isna_tp1)
    
  }
  
  return(data_filtered)
  
}

